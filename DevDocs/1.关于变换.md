## 向量的理解
- 我通常将向量理解成空间中的一个点的坐标，它代表从空间的原点开始，沿着N维的轴移动了多少个单位
- 一个空间由对应维度的基向量组成，比如某个三维空间的基坐标如下 
<pre>[i, 0, 0], [0, j, 0], [0, 0, k]</pre>
- 对于坐标(x, y, z)，相当于该点从原点开始，沿i轴移动x/i个单位，然后再沿j轴移动j/y单位，最后再沿着k轴移动z/k个单位
- 一个坐标是基于当前空间的描述，对于其他空间而言，这个点的坐标可能是不同的数值

## 矩阵的理解
- 而对于矩阵，我把它理解成一种变换的描述。它类似于函数，把一个向量转换成另一个向量<b><code>f(v1) = v2</code></b>，而这种变换可以是缩放，移动，旋转，以及他们的混合
    - 当然最重要的，矩阵还可以代表空间的变换，它可以将一个点的坐标转成相对于其他空间的坐标

## 矩阵的变换
- 可以把矩阵的每一列当作对向量对应轴的变换，比如下面这个矩阵
<pre>
[1, 0, 0]           |           [2, 0, 0]
[0, 1, 0]           |           [1, 1, 0]
[0, 0, 1]           |           [0, 0, 1]
</pre>
- 第一列由原本的(1, 0, 0)变成了(2, 1, 0)，影响的是向量的第一个分量。相当于应用这个矩阵的坐标x分量会被放大成原来的两倍，同时多沿Y轴移动 1*x 的值
    - 这里面坐标第一个分量并不仅仅代表x的值，而是表示x倍的基向量
<pre>
[2, 0, 0]         [x]         [2x] + [0x] + [0x]         [2x]
[1, 1, 0]    *    [y]    =    [1y] + [1y] + [0y]    =    [2y]
[0, 0, 1]         [z]         [0z] + [0z] + [1z]         [1z]
</pre>

## 缩放矩阵
- 很容易理解，缩放矩阵就是每一列在对应的分量上缩放N倍，比如第一列的x分量，第二列的y分量，第三列的z分量...
- 下列矩阵对一个向量进行缩放 (Sx, Sy, Sz) 倍
<pre>
[Sx,  0,  0]
[ 0, Sy,  0]
[ 0,  0, Sz]
</pre>

## 位移矩阵
- 位移通常无法用对应维数的矩阵来实现，试想一下矩阵乘法，你想位移某一个分量，但是矩阵的每一列都被对应分量以倍数增加
- 因此我们需要多定义一个维度来实现向量的位移，下列矩阵表示对一个二维向量进行位移 (Tx, Ty)
<pre>
[1, 0, Tx]         [x]         [x] + [0] + [Tx]         [x + Tx]
[0, 1, Ty]    *    [y]    =    [0] + [y] + [Ty]    =    [y + Ty]
[0, 0,  1]         [1]         [0] + [0] + [ 1]         [  1   ]
</pre>
- 为什么这里使用二维坐标来举例。想象一下你在一个二维空间里，除了xy还有一个第三维度的基向量(Tx, Ty, 1)，你的坐标在z分量的数值会同时影响xy两个分量，最终变换后的向量再舍弃掉z分量，回到二维平面上
    - 如果使用三维坐标来举例这个场景就很难想象了，三维坐标需要使用更高维度的分量w，这个w也叫做齐次坐标
    - w分量可以理解位其他维度位移的分量，比如位移矩阵<code><b> M * (x, y, z, w) = (x + wTx, y + wTy, z + wTz, w) </b></code>

## 旋转矩阵
- 旋转矩阵相比于其他矩阵会稍微复杂些，先看看二维旋转矩阵是怎么构造的，然后再扩展到更高维度
- 对于旋转矩阵Rot和向量x,y来说，我们有以下两个性质
    - Rot(x + y) = Rot(x) + Rot(y)
    - Rot(Nx) = N·Rot(x)
- 第一点很容易证明，对向量的旋转等同于对坐标系的反向旋转，想象一下，由原点，x, y构成的平行四边形，不管坐标系怎样旋转都不会改变形状
- 第二点同理，我甚至在脑海中构建了两个同心圆
- 因此，一个坐标为(x, y)的向量v，我们有Rot(v) = Rot(xi) + Rot(yj)。其中ij为基向量(1, 0), (0, 1)
- 基坐标i逆时针旋转angle度后为 (cos(angle), sin(angle))，基坐标j为 (-sin(angle), cos(angle))
- 最终构造的旋转矩阵如下
<pre>
[cos, -sin]    *    [x]    =    x * [cos] + y * [-sin]
[sin,  cos]         [y]         x * [sin] + y * [ cos]
</pre>
- 三维的旋转矩阵同理，假设沿着x轴旋转，旋转后基坐标x还是(1, 0, 0)，构造的旋转矩阵如下
    - 注意，我这里的旋转参考的Unity坐标系采用左手坐标系，定义旋转方向的时候使用左手法则，大拇指指向旋转轴x，y在z轴的左侧，y轴朝顺时针旋转为正方向
    - 再补充一下，左手坐标系，想象xy为一个平面，z轴是远离你的方向。或者左手张开，大拇指为x，食指为y，中指为z
<pre>
[1,   0,    0]
[0, cos, -sin]  (构建的旋转矩阵左右坐标系都一样，只是需要一个想象成型的坐标系)
[0, sin,  cos]
对应的我们很容易得到绕yz轴旋转的矩阵
[ cos, 0, sin]    [cos, -sin, 0]
[   0, 1,   0]    [sin,  cos, 0]
[-sin, 0, cos]    [  0,    0, 1]
</pre>
- 旋转矩阵依次作用于对应向量，最终生成的旋转矩阵R = Rz * Ry * Rx。这里以先x，再y，最后z的顺序来旋转

## 万向锁
- 我们上面得到的旋转矩阵复合相当于对旋转后的基坐标再旋转，即坐标轴会随着物体本身一起旋转，这种旋转变换被称作是动态欧拉角。使用动态欧拉角会出现万向锁现象
- 网上对于万向锁的解释有很多，但是大多都是使用平衡环架来讲解，而欧拉角旋转为什么会和平衡环架一样工作，为什么先转的轴会带动后转的轴，为什么后转的轴不能影响先转的轴，关于这部分我研究了很久，也查询了大量的资料...
- 我认为理解这个问题的关键要把整个旋转过程看作是一次变换，而不是多次的旋转
- 举个例子，假设欧拉角旋转的顺序为x-y-z，我们分别沿x轴旋转10度数，y轴旋转90度，物体本身的坐标系变换如下(画的有一点点抽象，又懒得引用图片，最好有个笔在纸上画画看)
<pre>
Y     Z                                                Y
|    /                                                /
|   /                                                /
|  /                       ->                       /_ _ _ _  Z
| /                                                 \
|/_ _ _ _ _ _ _X                                     \
                                                      \ X
</pre>
- 变换之后，此时Z轴落到初始状态X轴的方向，我们再沿着Z轴旋转，也只是和之前沿着X轴旋转一样，物体丢失了一个沿着最终Z轴旋转的轴
- 那么是不是再沿着X轴旋转就好了？因为此时X轴接近于初始状态Z轴的方向
- 其实并非如此，这样只是把每次旋转都当成了一次运动，比如从初始状态沿X旋转10度到状态A，然后再沿Y旋转90度到状态B，然后再沿X旋转X度到状态C。而实际的旋转只是一次完整的变换，先沿X轴旋转10+X度，然后沿Y轴旋转90度，...
- 仔细思考一下这个过程，假设有一台机头沿着Z轴的飞机，沿着XY变换之后，它将没法再沿着机身Roll(对于机头来说是Pitch)

## 四元数
- 丢个[Wiki链接](https://zh.wikipedia.org/wiki/%E5%9B%9B%E5%85%83%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E6%97%8B%E8%BD%AC)在这后面慢慢看，事实上每个字我都认识，但是就是看不懂

## LookAt矩阵
- LookAt通常用于构建View矩阵，View矩阵的本质是从世界空间变换到相机空间，这个变换分为两个阶段，先是位移到相机空间的原点，然后构造一个旋转矩阵把向量变换到相机空间
- 这个旋转矩阵的构建本质上就是追踪基向量的变换，相机空间的Front，Up，Right是世界空间Z，Y，X变换后的结果
- 因此整个LookAt矩阵的计算如下
<pre>
[Rx, Ux, Fx, 0]         [1, 0, 0, Tx]
[Ry, Uy, Fy, 0]    *    [0, 1, 0, Ty]    *    V
[Rz, Uz, Fz, 0]         [0, 0, 1, Tz]
[ 0,  0,  0, 1]         [0, 0, 0,  1]
</pre>
- 注意这里是列主序构造的矩阵，和OpenGL教程上提到的不一致

## 投影矩阵
- 之后有空的时候我会看看正交和透视投影矩阵是怎样构建的

## 相机空间的构造
- 给定俯仰角(Pitch)和偏航角(Yaw)，我们有如下代码用于构建相机空间的基向量
```cpp
    void updateCameraVectors()
    {
        glm::vec3 front;
        front.x = cos(glm::radians(Yaw)) * cos(glm::radians(Pitch));
        front.y = sin(glm::radians(Pitch));
        front.z = sin(glm::radians(Yaw)) * cos(glm::radians(Pitch));
        Front = glm::normalize(front);
        Right = glm::normalize(glm::cross(Front, WorldUp)); 
        Up = glm::normalize(glm::cross(Right, Front));
    }
```
- 我认为理解这段计算的关键是想象一个球形空间(半径为1)，一个向量长度为1，当向量上下旋转时，其落在xz平面的投影会受影响缩小，对应的XZ分量也会缩小(想象向上旋转一个向量，然后向量触碰到球面的点向XZ平面垂直一个点与原点构成一个直角三角形，因为向量长度始终为1，投影变成cos(Pitch)，对应的xz分量也缩放cos(Pitch))
- 同理向右偏航的一个向量，x分量变为cos(Yaw), z分量变为sin(Yaw)
    - 谁是sin谁是cos要看偏航角0度为多少，根据答案出问题，OpenGL的这个相机从X正方向开始计算偏航角，因此我们看向屏幕的那个方向是偏航角-90的朝向 cos(-90) = -1，方向就为(0,0,-1)，这里的坐标基于右手坐标系

## 参考资料
- [线性代数的本质](https://www.bilibili.com/video/BV1ys411472E/?spm_id_from=333.999.0.0&vd_source=1b2c3d5efac2682055190e807e57df67)(理解变换必不可缺的视频，10000%推荐！)
- [万向锁的理解](https://www.youtube.com/watch?v=vLDn-ZITDgA)(当我查了一天万向锁结果大家都是讲解平衡环架的时候，这个视频出现了...当当当当当当当当~)
- [四元数WIKI](https://zh.wikipedia.org/wiki/%E5%9B%9B%E5%85%83%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E6%97%8B%E8%BD%AC)(我还会再回来的)
- [四元数](https://www.youtube.com/watch?v=d4EgbgTm0Bg&t=886s)(即便看不懂我也不会质疑3Imaginary1Real(bushi)巨佬的视频)